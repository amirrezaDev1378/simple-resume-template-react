{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'; // import { fetchCount } from './counterAPI';\n\nconst initialState = {\n  value: 'mame',\n  status: 'idle'\n}; // The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n// export const incrementAsync = createAsyncThunk(\n//   'counter/fetchCount',\n//   async (amount) => {\n//     const response = await fetchCount(amount);\n//     // The value we return becomes the `fulfilled` action payload\n//     return response.data;\n//   }\n// );\n\nexport const TextSlice = createSlice({\n  name: 'text',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    addText: state => {\n      state.value = 'Math';\n    },\n    // Use the PayloadAction type to declare the contents of `action.payload`\n    changeText: (state, action) => {\n      state.value = action.payload;\n    }\n  } // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  //   extraReducers: (builder) => {\n  //     builder\n  //       .addCase(incrementAsync.pending, (state) => {\n  //         state.status = 'loading';\n  //       })\n  //       .addCase(incrementAsync.fulfilled, (state, action) => {\n  //         state.status = 'idle';\n  //         state.value += action.payload;\n  //       });\n  //   },\n\n});\nexport const {\n  addText,\n  changeText\n} = TextSlice.actions; // The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\n\nexport const selectValue = state => state.text.value; // We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\n\nexport const TestFunc = amount => (dispatch, getState) => {\n  const currentValue = selectValue(getState());\n  console.log(currentValue);\n};\nexport default TextSlice.reducer;","map":{"version":3,"sources":["C:/Users/AMIR/Desktop/projects/react-starter/src/features/textInput/TextSlice.js"],"names":["createAsyncThunk","createSlice","initialState","value","status","TextSlice","name","reducers","addText","state","changeText","action","payload","actions","selectValue","text","TestFunc","amount","dispatch","getState","currentValue","console","log","reducer"],"mappings":"AAAA,SAASA,gBAAT,EAA2BC,WAA3B,QAA8C,kBAA9C,C,CACA;;AAEA,MAAMC,YAAY,GAAG;AACjBC,EAAAA,KAAK,EAAC,MADW;AAEjBC,EAAAA,MAAM,EAAE;AAFS,CAArB,C,CAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,SAAS,GAAGJ,WAAW,CAAC;AACjCK,EAAAA,IAAI,EAAE,MAD2B;AAEjCJ,EAAAA,YAFiC;AAGjC;AACAK,EAAAA,QAAQ,EAAE;AAENC,IAAAA,OAAO,EAAGC,KAAD,IAAW;AAChBA,MAAAA,KAAK,CAACN,KAAN,GAAc,MAAd;AACH,KAJK;AAMN;AACAO,IAAAA,UAAU,EAAE,CAACD,KAAD,EAAQE,MAAR,KAAmB;AAC3BF,MAAAA,KAAK,CAACN,KAAN,GAAcQ,MAAM,CAACC,OAArB;AACH;AATK,GAJuB,CAejC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1BiC,CAAD,CAA7B;AA6BP,OAAO,MAAM;AAAEJ,EAAAA,OAAF;AAAWE,EAAAA;AAAX,IAA0BL,SAAS,CAACQ,OAA1C,C,CAEP;AACA;AACA;;AACA,OAAO,MAAMC,WAAW,GAAIL,KAAD,IAAWA,KAAK,CAACM,IAAN,CAAWZ,KAA1C,C,CAEP;AACA;;AACA,OAAO,MAAMa,QAAQ,GAAIC,MAAD,IAAY,CAACC,QAAD,EAAWC,QAAX,KAAwB;AACxD,QAAMC,YAAY,GAAGN,WAAW,CAACK,QAAQ,EAAT,CAAhC;AACAE,EAAAA,OAAO,CAACC,GAAR,CAAYF,YAAZ;AACH,CAHM;AAKP,eAAef,SAAS,CAACkB,OAAzB","sourcesContent":["import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\n// import { fetchCount } from './counterAPI';\r\n\r\nconst initialState = {\r\n    value:'mame',\r\n    status: 'idle',\r\n};\r\n\r\n// The function below is called a thunk and allows us to perform async logic. It\r\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\r\n// will call the thunk with the `dispatch` function as the first argument. Async\r\n// code can then be executed and other actions can be dispatched. Thunks are\r\n// typically used to make async requests.\r\n// export const incrementAsync = createAsyncThunk(\r\n//   'counter/fetchCount',\r\n//   async (amount) => {\r\n//     const response = await fetchCount(amount);\r\n//     // The value we return becomes the `fulfilled` action payload\r\n//     return response.data;\r\n//   }\r\n// );\r\n\r\nexport const TextSlice = createSlice({\r\n    name: 'text',\r\n    initialState,\r\n    // The `reducers` field lets us define reducers and generate associated actions\r\n    reducers: {\r\n\r\n        addText: (state) => {\r\n            state.value = 'Math'\r\n        },\r\n\r\n        // Use the PayloadAction type to declare the contents of `action.payload`\r\n        changeText: (state, action) => {\r\n            state.value = action.payload;\r\n        },\r\n    },\r\n    // The `extraReducers` field lets the slice handle actions defined elsewhere,\r\n    // including actions generated by createAsyncThunk or in other slices.\r\n    //   extraReducers: (builder) => {\r\n    //     builder\r\n    //       .addCase(incrementAsync.pending, (state) => {\r\n    //         state.status = 'loading';\r\n    //       })\r\n    //       .addCase(incrementAsync.fulfilled, (state, action) => {\r\n    //         state.status = 'idle';\r\n    //         state.value += action.payload;\r\n    //       });\r\n    //   },\r\n});\r\n\r\nexport const { addText, changeText } = TextSlice.actions;\r\n\r\n// The function below is called a selector and allows us to select a value from\r\n// the state. Selectors can also be defined inline where they're used instead of\r\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\r\nexport const selectValue = (state) => state.text.value;\r\n\r\n// We can also write thunks by hand, which may contain both sync and async logic.\r\n// Here's an example of conditionally dispatching actions based on current state.\r\nexport const TestFunc = (amount) => (dispatch, getState) => {\r\n    const currentValue = selectValue(getState());\r\n    console.log(currentValue)\r\n};\r\n\r\nexport default TextSlice.reducer;\r\n"]},"metadata":{},"sourceType":"module"}
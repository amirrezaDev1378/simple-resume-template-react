{"ast":null,"code":"import{createAsyncThunk,createSlice}from'@reduxjs/toolkit';// import { fetchCount } from './counterAPI';\nvar initialState={value:'mame',status:'idle'};// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n// export const incrementAsync = createAsyncThunk(\n//   'counter/fetchCount',\n//   async (amount) => {\n//     const response = await fetchCount(amount);\n//     // The value we return becomes the `fulfilled` action payload\n//     return response.data;\n//   }\n// );\nexport var TextSlice=createSlice({name:'text',initialState:initialState,// The `reducers` field lets us define reducers and generate associated actions\nreducers:{addText:function addText(state){state.value='Math';},// Use the PayloadAction type to declare the contents of `action.payload`\nchangeText:function changeText(state,action){state.value=action.payload;}}// The `extraReducers` field lets the slice handle actions defined elsewhere,\n// including actions generated by createAsyncThunk or in other slices.\n//   extraReducers: (builder) => {\n//     builder\n//       .addCase(incrementAsync.pending, (state) => {\n//         state.status = 'loading';\n//       })\n//       .addCase(incrementAsync.fulfilled, (state, action) => {\n//         state.status = 'idle';\n//         state.value += action.payload;\n//       });\n//   },\n});var _TextSlice$actions=TextSlice.actions,addText=_TextSlice$actions.addText,changeText=_TextSlice$actions.changeText;// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\nexport{addText,changeText};export var selectValue=function selectValue(state){return state.text.value;};// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\nexport var TestFunc=function TestFunc(amount){return function(dispatch,getState){var currentValue=selectValue(getState());console.log(currentValue);};};export default TextSlice.reducer;","map":{"version":3,"sources":["C:/Users/AMIR/Desktop/projects/resume/src/features/textInput/TextSlice.js"],"names":["createAsyncThunk","createSlice","initialState","value","status","TextSlice","name","reducers","addText","state","changeText","action","payload","actions","selectValue","text","TestFunc","amount","dispatch","getState","currentValue","console","log","reducer"],"mappings":"AAAA,OAASA,gBAAT,CAA2BC,WAA3B,KAA8C,kBAA9C,CACA;AAEA,GAAMC,CAAAA,YAAY,CAAG,CACjBC,KAAK,CAAC,MADW,CAEjBC,MAAM,CAAE,MAFS,CAArB,CAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAO,IAAMC,CAAAA,SAAS,CAAGJ,WAAW,CAAC,CACjCK,IAAI,CAAE,MAD2B,CAEjCJ,YAAY,CAAZA,YAFiC,CAGjC;AACAK,QAAQ,CAAE,CAENC,OAAO,CAAE,iBAACC,KAAD,CAAW,CAChBA,KAAK,CAACN,KAAN,CAAc,MAAd,CACH,CAJK,CAMN;AACAO,UAAU,CAAE,oBAACD,KAAD,CAAQE,MAAR,CAAmB,CAC3BF,KAAK,CAACN,KAAN,CAAcQ,MAAM,CAACC,OAArB,CACH,CATK,CAWV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1BiC,CAAD,CAA7B,CA6BA,uBAAgCP,SAAS,CAACQ,OAA1C,CAAQL,OAAR,oBAAQA,OAAR,CAAiBE,UAAjB,oBAAiBA,UAAjB,CAEP;AACA;AACA;2BACA,MAAO,IAAMI,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAACL,KAAD,QAAWA,CAAAA,KAAK,CAACM,IAAN,CAAWZ,KAAtB,EAApB,CAEP;AACA;AACA,MAAO,IAAMa,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,CAACC,MAAD,QAAY,UAACC,QAAD,CAAWC,QAAX,CAAwB,CACxD,GAAMC,CAAAA,YAAY,CAAGN,WAAW,CAACK,QAAQ,EAAT,CAAhC,CACAE,OAAO,CAACC,GAAR,CAAYF,YAAZ,EACH,CAHuB,EAAjB,CAKP,cAAef,CAAAA,SAAS,CAACkB,OAAzB","sourcesContent":["import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\n// import { fetchCount } from './counterAPI';\r\n\r\nconst initialState = {\r\n    value:'mame',\r\n    status: 'idle',\r\n};\r\n\r\n// The function below is called a thunk and allows us to perform async logic. It\r\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\r\n// will call the thunk with the `dispatch` function as the first argument. Async\r\n// code can then be executed and other actions can be dispatched. Thunks are\r\n// typically used to make async requests.\r\n// export const incrementAsync = createAsyncThunk(\r\n//   'counter/fetchCount',\r\n//   async (amount) => {\r\n//     const response = await fetchCount(amount);\r\n//     // The value we return becomes the `fulfilled` action payload\r\n//     return response.data;\r\n//   }\r\n// );\r\n\r\nexport const TextSlice = createSlice({\r\n    name: 'text',\r\n    initialState,\r\n    // The `reducers` field lets us define reducers and generate associated actions\r\n    reducers: {\r\n\r\n        addText: (state) => {\r\n            state.value = 'Math'\r\n        },\r\n\r\n        // Use the PayloadAction type to declare the contents of `action.payload`\r\n        changeText: (state, action) => {\r\n            state.value = action.payload;\r\n        },\r\n    },\r\n    // The `extraReducers` field lets the slice handle actions defined elsewhere,\r\n    // including actions generated by createAsyncThunk or in other slices.\r\n    //   extraReducers: (builder) => {\r\n    //     builder\r\n    //       .addCase(incrementAsync.pending, (state) => {\r\n    //         state.status = 'loading';\r\n    //       })\r\n    //       .addCase(incrementAsync.fulfilled, (state, action) => {\r\n    //         state.status = 'idle';\r\n    //         state.value += action.payload;\r\n    //       });\r\n    //   },\r\n});\r\n\r\nexport const { addText, changeText } = TextSlice.actions;\r\n\r\n// The function below is called a selector and allows us to select a value from\r\n// the state. Selectors can also be defined inline where they're used instead of\r\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\r\nexport const selectValue = (state) => state.text.value;\r\n\r\n// We can also write thunks by hand, which may contain both sync and async logic.\r\n// Here's an example of conditionally dispatching actions based on current state.\r\nexport const TestFunc = (amount) => (dispatch, getState) => {\r\n    const currentValue = selectValue(getState());\r\n    console.log(currentValue)\r\n};\r\n\r\nexport default TextSlice.reducer;\r\n"]},"metadata":{},"sourceType":"module"}